<h1>Тестове завдання для PHP розробників</h1>
Написати на PHP 7.1 програму:
<ul>
<li>Повинні існувати кілька видів собак = сіба-іну, мопс, такса, плюшевий лабрадор, гумова такса з пищалкою.</li>
<li>Собаки повинні вміти видавати звуки (гавкати, пищати) і полювати. При цьому варто пам'ятати, що мопсу полюватиме лінь, деякі іграшки не видають звуків і точно не зможуть полювати.</li>
<li>Ми можемо написати команду виду "mops sound" та отримати у відповідь "woof! woof!", далі за аналогією. Як реалізується консольний інтерфейс, значення не має.</li>
<li>Написати тести за допомогою phpunit.</li>
</ul>

<h1>Питання:</h1>
<h3>Як працюють індекси у БД?</h3>
<p style="color: #2ca02c">Индексы нужны для ускорения операций поиска, фильтрации и сортировки данных в таблицах. Они позволяют базе данных быстро находить нужные записи, минимизируя количество записей, которые нужно просматривать при выполнении запросов. Индексы аналогичны индексам в книге: они обеспечивают быстрый доступ к нужной информации.</p>

<h3>Які є JOIN в MySQL?</h3>
<p style="color: #2ca02c">INNER JOIN: Возвращает только те строки, для которых существуют совпадающие значения в обеих таблицах.</p>
<pre>
SELECT orders.order_id, customers.customer_name
FROM orders
INNER JOIN customers ON orders.customer_id = customers.customer_id;
</pre>
<p style="color: #2ca02c">LEFT JOIN (или LEFT OUTER JOIN): Возвращает все строки из левой (первой) таблицы и соответствующие строки из правой (второй) таблицы. Если соответствия нет, то для правой таблицы будут возвращены NULL-значения.</p>
<pre>
SELECT customers.customer_name, orders.order_id
FROM customers
LEFT JOIN orders ON customers.customer_id = orders.customer_id;
</pre>
<p style="color: #2ca02c">RIGHT JOIN (или RIGHT OUTER JOIN): Похож на LEFT JOIN, но возвращает все строки из правой таблицы и соответствующие строки из левой таблицы. Если соответствия нет, то для левой таблицы будут возвращены NULL-значения.</p>
<pre>
SELECT orders.order_id, customers.customer_name
FROM orders
RIGHT JOIN customers ON orders.customer_id = customers.customer_id;
</pre>
<p style="color: #2ca02c">FULL JOIN (или FULL OUTER JOIN): Возвращает все строки из обеих таблиц, соответствующие строки объединяются, а несоответствующие заполняются NULL-значениями.</p>
<pre>
SELECT customers.customer_name, orders.order_id
FROM customers
FULL JOIN orders ON customers.customer_id = orders.customer_id;
</pre>
<p style="color: #2ca02c">CROSS JOIN: Выполняет декартово произведение всех строк из первой таблицы со всеми строками из второй таблицы. Этот тип JOIN создает комбинаторный результат, и его следует использовать осторожно.</p>
<pre>
SELECT *
FROM customers
CROSS JOIN orders;
</pre>

<h3>Що таке dependency inversion?</h3>
<p style="color: #2ca02c">
Dependency Inversion (Инверсия зависимостей) - это один из принципов SOLID, который описывает подход к организации кода и зависимостей между компонентами в программе. Принцип Dependency Inversion обращает внимание на то, как зависимости между классами могут быть организованы для улучшения гибкости, переиспользуемости и тестируемости кода.<br><br>
Принцип состоит из двух ключевых аспектов:</p>
<ul style="color: #2ca02c">
<li>Высокоуровневые модули не должны зависеть от низкоуровневых модулей. Оба должны зависеть от абстракций.</li>
<li>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</li>
</ul>
<p style="color: #2ca02c">
В контексте практического программирования это означает, что вместо того чтобы выстраивать зависимости напрямую от низкоуровневых компонентов к высокоуровневым, мы создаем абстракции, через которые эти компоненты взаимодействуют. Это может уменьшить связанность между различными частями системы, делая ее более гибкой и менее подверженной изменениям.
</p>

<h3>У чому різниця між GET та POST запитом?</h3>
<p style="color: #2ca02c">
GET-запрос:
</p>
<ul style="color: #2ca02c">
<li>Используется для получения данных с сервера.</li>
<li>Параметры запроса (например, данные для поиска или фильтрации) обычно передаются через URL в виде строки запроса.</li>
<li>Ограничение на длину URL в разных браузерах может повлиять на возможность передачи больших объемов данных.</li>
<li>GET-запросы могут быть закешированы браузером.</li>
<li>Они могут быть сохранены в истории браузера.</li>
<li>Они могут быть подвержены атакам CSRF (межсайтовая подделка запроса).</li>
</ul>
<p style="color: #2ca02c">
POST-запрос:
</p>
<ul style="color: #2ca02c">
<li>Используется для отправки данных на сервер.</li>
<li>Параметры запроса передаются в теле запроса, что позволяет передавать большие объемы данных.</li>
<li>POST-запросы не кэшируются браузером.</li>
<li>Они не сохраняются в истории браузера.</li>
<li>POST-запросы более безопасны в контексте атак CSRF, так как они могут быть защищены механизмами вроде токенов.</li>
</ul>
<p style="color: #2ca02c">
Когда использовать GET:
</p>
<ul style="color: #2ca02c">
<li>Получение данных с сервера (например, отображение статей на веб-странице).</li>
<li>Запросы, которые не изменяют состояние сервера.</li>
<li>Когда параметры запроса можно легко передать через URL.</li>
</ul>
<p style="color: #2ca02c">
Когда использовать POST:
</p>
<ul style="color: #2ca02c">
<li>Отправка данных на сервер (например, отправка формы).</li>
<li>Запросы, которые изменяют состояние сервера (создание, обновление или удаление данных).</li>
<li>Отправка больших объемов данных.</li>
<li>Когда безопасность и защита от CSRF атак важны.</li>
</ul>


<h3>У чому різниця дзвінка self і static?</h3>
<p style="color: #2ca02c">
В PHP, как и в некоторых других языках программирования, self и static - это два ключевых слова, используемых в контексте классов для работы с методами и свойствами классов. Они имеют некоторые различия в поведении, особенно касающиеся наследования и контекста вызова. Давайте рассмотрим их отличия:
</p>
<p style="color: #2ca02c">
self:
</p>
<ul style="color: #2ca02c">
<li>self используется для обращения к статическим методам и свойствам внутри самого класса, в котором оно определено.</li>
<li>self ссылается на текущий класс, в котором это ключевое слово используется.</li>
<li>self не учитывает переопределения методов и свойств в подклассах. Всегда будет обращаться к методам и свойствам, определенным в текущем классе.</li>
</ul>
<pre>
class ParentClass {
    public static $var = 10;
    public static function printVar() {
        echo self::$var;
    }
}

class ChildClass extends ParentClass {
    public static $var = 20;
}

ChildClass::printVar();  // Выведет: 10
</pre>
<p style="color: #2ca02c">
static:
</p>
<ul style="color: #2ca02c">
<li>static также используется для обращения к статическим методам и свойствам, но оно учитывает контекст вызова.</li>
<li>Если метод или свойство переопределены в подклассе, то static будет ссылаться на класс, в контексте которого был вызван метод, а не на класс, где оно определено.</li>
</ul>
<pre>
class ParentClass {
    public static $var = 10;
    public static function printVar() {
        echo static::$var;
    }
}

class ChildClass extends ParentClass {
    public static $var = 20;
}

ChildClass::printVar();  // Выведет: 20
</pre>
<p style="color: #2ca02c">
В этом примере static учитывает переопределение переменной $var в подклассе ChildClass и ссылается на переменную, определенную в контексте вызова, то есть в подклассе.
</p>
<p style="color: #2ca02c">
В целом, self и static - это ключевые слова, позволяющие работать со статическими методами и свойствами классов. Однако использование static позволяет учитывать контекст вызова и переопределение, делая код более гибким в ситуациях с наследованием.
</p>

<h3>Яка різниця між MVP та MVC?</h3>
<p style="color: #2ca02c">
MVP (Model-View-Presenter) и MVC (Model-View-Controller) - это две различные архитектурные парадигмы, используемые в разработке программного обеспечения для структурирования пользовательского интерфейса и управления данными. Они имеют общие концепции, но с некоторыми отличиями в организации и взаимодействии компонентов.
</p>
<p style="color: #2ca02c">
MVC (Model-View-Controller):
</p>
<p style="color: #2ca02c">
Модель (Model): Это представление данных и бизнес-логики. Модель обрабатывает данные, валидацию и выполнение бизнес-операций.
Представление (View): Отображает данные пользователю и обрабатывает пользовательский ввод. Оно отвечает за визуальное представление данных.
Контроллер (Controller): Обрабатывает пользовательский ввод, решает, какой функциональности следует вызвать на основе этого ввода, и обновляет модель и представление.
</p>
<p style="color: #2ca02c">
MVP (Model-View-Presenter):
</p>
<p style="color: #2ca02c">
Модель (Model): Аналогично MVC, это слой данных и бизнес-логики.
Представление (View): Отвечает за отображение данных и обработку пользовательского ввода, но оно пассивнее по сравнению с представлением в MVC. В MVP представление знает о презентере, но не наоборот.
Презентер (Presenter): Презентер обрабатывает пользовательский ввод, обновляет модель и обновляет представление. Он играет активную роль и содержит логику, которая в MVC была разнесена между контроллером и представлением.
</p>
<p style="color: #2ca02c">
Сравнение:
</p>
<p style="color: #2ca02c">
В MVC контроллер обычно отвечает за более широкий спектр обработки пользовательского ввода и бизнес-логики, в то время как в MVP логика больше сосредоточена в презентере.
В MVP у представления более ограниченная роль в обработке событий. Оно передает события и запросы на обновление данных презентеру.
MVP обычно считается более тестируемой архитектурой, так как логика сосредоточена в презентере, который может быть легко оттестирован в изоляции.
Выбор между MVC и MVP зависит от требований проекта, структуры команды и личных предпочтений разработчиков. Оба шаблона позволяют достичь высокой степени разделения забот и поддерживаемости в коде.
</p>

<h3>Яка різниця між == та ===?</h3>
<p style="color: #2ca02c">
В случае === сравнение значений идёт с учётом типа данных.
</p>

<h3>Що таке final class та final method?</h3>
<p style="color: #2ca02c">
В языках программирования, которые поддерживают объектно-ориентированную парадигму (такие как Java, PHP, C#), ключевое слово final используется для указания, что определенный элемент (класс, метод или свойство) не может быть изменен или наследован.
</p>
<p style="color: #2ca02c">
Final class (финальный класс):
</p>
<p style="color: #2ca02c">
Когда класс объявлен с ключевым словом final, это означает, что этот класс не может быть расширен (подклассом).
Другими словами, нельзя создать подкласс (наследник) от класса, который объявлен как final.
</p>
<pre>
final class MyFinalClass {
    // Код класса
}
// Ошибка! Нельзя создать подкласс от MyFinalClass
class Subclass extends MyFinalClass {
}
</pre> 
<p style="color: #2ca02c">
Final method (финальный метод):
</p>
<p style="color: #2ca02c">
Когда метод объявлен с ключевым словом final, это означает, что этот метод не может быть переопределен в подклассе.
Метод, объявленный как final, должен иметь тот же доступ (public, protected, private), что и метод в родительском классе.
</p>
<pre>
class ParentClass {
    final public function myFinalMethod() {
        // Код метода
    }
}

class ChildClass extends ParentClass {
    // Ошибка! Нельзя переопределить метод myFinalMethod
    public function myFinalMethod() {
        // Код метода в подклассе
    }
}
</pre>
<p style="color: #2ca02c">
Использование ключевого слова final может быть полезным, когда вы хотите зафиксировать определенный класс или метод и предотвратить его изменение или переопределение. Такой подход может помочь обеспечить безопасность и предсказуемость поведения в коде.
</p>

<h3>Якими фреймворками працювали?</h3>
<p style="color: #2ca02c">LARAVEL. Очень хорошо разбираюсь в UIKIT.</p>

<h3>Що можете розповісти про свої навички, що дають вам перевагу? Які з них відповідають нашим вимогам?</h3>
<ul style="color: #2ca02c">
<li>Умение анализировать сложные задачи и разрабатывать эффективные алгоритмы для их решения </li>
<li>Знание HTML, CSS и JavaScript, а также фреймворков и различных библиотек.</li>
<li>Навыки в создании скриптов и автоматизации задач.</li>
<li>Знание SQL и опыт работы с различными базами данных (MySQL, MSSQL, Oracle), опыт работы с Eloquent ORM.</li>
<li>Опыт работы с big data (таблицы с более 1 млн записей).</li>
<li>Опыт командной работы, использование систем контроля версий (Git).</li>
</ul>